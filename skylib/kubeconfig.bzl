# Copyright 2021 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

"""
Kubectl configuration rules
"""

load("@bazel_skylib//lib:paths.bzl", "paths")
load("@bazel_skylib//lib:shell.bzl", "shell")

KubeconfigInfo = provider(fields = [
    "server",
    "cluster",
    "user",
])

def _kubeconfig_impl(ctx):
    kubeconfig_file = ctx.actions.declare_file(ctx.label.name)
    ctx.actions.symlink(output = kubeconfig_file, target_file = ctx.file.config)
    files = depset(direct = [kubeconfig_file])
    runfiles = ctx.runfiles(files = [kubeconfig_file])
    return [
        DefaultInfo(files = files, runfiles = runfiles),
        KubeconfigInfo(
            server = ctx.attr.server,
            cluster = ctx.attr.cluster,
            user = ctx.attr.user,
        ),
    ]

kubeconfig = rule(
    implementation = _kubeconfig_impl,
    attrs = {
        "config": attr.label(
            doc = "Config file.",
            allow_single_file = True,
            mandatory = True,
        ),
        "server": attr.string(
            doc = "Optional Kubernetes server url.",
            mandatory = False,
        ),
        "cluster": attr.string(
            doc = "Optional Kubernetes cluster name.",
            mandatory = False,
        ),
        "user": attr.string(
            doc = "Optional Kubernetes user name.",
            mandatory = True,
        ),
    },
    provides = [DefaultInfo, KubeconfigInfo],
)

_KUBECONFIG_CONTEXT_TEMPLATE = """
apiVersion: v1
kind: Config
contexts:
- context:
    cluster: {cluster}
    user: {user}
  name: {cluster}-{user}
current-context: {cluster}-{user}
"""

_KUBECONFIG_BUILD_TEMPLATE = """# Generated by kubeconfig_configure repostiory rule

load("@com_adobe_rules_gitops//gitops:defs.bzl", "kubeconfig")

exports_files(["kubectl"])

kubeconfig(
    name = "kubeconfig",
    config = ":config",
    server = "{server}",
    cluster = "{cluster}",
    user = "{user}",
    visibility = ["//visibility:public"],
)
"""

# kubectl template
def _kubectl_config(repository_ctx, kubeconfig, args):
    kubectl = repository_ctx.path("kubectl")
    exec_result = repository_ctx.execute(
        [kubectl, "--kubeconfig", kubeconfig, "config"] + args,
        environment = {
            # prevent kubectl config to stumble on shared .kube/config.lock file
            "HOME": str(repository_ctx.path(".")),
        },
        quiet = True,
    )
    if exec_result.return_code != 0:
        fail("Error executing kubectl config %s" % " ".join(args))
    return exec_result.stdout

def _kubectl_config_query(repository_ctx, kubeconfig, jsonpath):
    kubectl = repository_ctx.path("kubectl")
    query = ["view", "--raw", "-o", "jsonpath=%s" % shell.quote(jsonpath)]
    exec_result = repository_ctx.execute(
        [kubectl, "--kubeconfig", kubeconfig, "config"] + query,
        environment = {
            # prevent kubectl config to stumble on shared .kube/config.lock file
            "HOME": str(repository_ctx.path(".")),
        },
        quiet = True,
    )
    if exec_result.return_code != 0:
        fail("Error executing kubectl config %s" % " ".join(query))
    return exec_result.stdout.strip("\"\'")

def _real_kubeconfig_path(repository_ctx, kubeconfig, path):
    return repository_ctx.path(paths.normalize(paths.join(str(kubeconfig.dirname), str(path))))

def _kubeconfig_configure_impl(repository_ctx):
    """Find local kubernetes certificates"""

    # find and symlink kubectl
    kubectl = repository_ctx.which("kubectl")
    if not kubectl:
        fail("Unable to find kubectl executable. PATH=%s" % repository_ctx.path)
    repository_ctx.symlink(kubectl, "kubectl")

    home = repository_ctx.path(repository_ctx.os.environ["HOME"])

    # use provided user name or fall back to current os user name
    if repository_ctx.attr.user:
        user = repository_ctx.attr.user
    elif "USER" in repository_ctx.os.environ:
        user = repository_ctx.os.environ["USER"]
    else:
        exec_result = repository_ctx.execute(["whoami"])
        if exec_result.return_code != 0:
            fail("Error detecting current user")
        user = exec_result.stdout.rstrip()

    can_symlink = True
    token = None
    ca_crt = None
    kubecert_cert = None
    kubecert_key = None
    server = repository_ctx.attr.server
    host_kubeconfig = None

    # check service account first
    serviceaccount = repository_ctx.path("/var/run/secrets/kubernetes.io/serviceaccount")
    if serviceaccount.exists:
        ca_crt = repository_ctx.path("/var/run/secrets/kubernetes.io/serviceaccount/ca.crt")
        token_file = serviceaccount.get_child("token")
        if token_file.exists:
            exec_result = repository_ctx.execute(["cat", token_file.realpath])
            if exec_result.return_code != 0:
                fail("Error reading user token")
            token = exec_result.stdout.rstrip()

        # use master url from the environemnt
        if "KUBERNETES_SERVICE_HOST" in repository_ctx.os.environ:
            server = "https://%s:%s" % (
                repository_ctx.os.environ["KUBERNETES_SERVICE_HOST"],
                repository_ctx.os.environ["KUBERNETES_SERVICE_PORT"],
            )
        else:
            # fall back to the default
            server = "https://kubernetes.default"

        # we can't possibly have a kubeconfig file to symlink
        can_symlink = False
    else:
        # check host kubectl configuration file
        host_kubeconfig = home.get_child(".kube").get_child("config")
        if host_kubeconfig.exists:
            # resolve posible relative path values
            # the test setup script will symlink kubeconfig file into the test runfiles subtree.
            # the relative path resulution will break.
            ca_crt = _kubectl_config_query(
                repository_ctx,
                host_kubeconfig.realpath,
                "{.clusters[?(@.name == \"%s\")].cluster.certificate-authority}" % repository_ctx.attr.cluster,
            )
            if ca_crt:
                if not paths.is_absolute(str(ca_crt)):
                    ca_crt = _real_kubeconfig_path(repository_ctx, host_kubeconfig, ca_crt)
                    can_symlink = False
                    if not server:
                        # read the cluster server url if not specified
                        # to be able to update kubeconfig later we will need bouth ca_crt and server values
                        server = _kubectl_config_query(
                            repository_ctx,
                            host_kubeconfig.realpath,
                            "{.clusters[?(@.name == \"%s\")].cluster.server}" % repository_ctx.attr.cluster,
                        )
                else:
                    ca_crt = repository_ctx.path(ca_crt)  # requred to be a path object later

            kubecert_cert = _kubectl_config_query(
                repository_ctx,
                host_kubeconfig.realpath,
                "{.users[?(@.name == \"%s\")].user.client-certificate}" % user,
            )
            if kubecert_cert:
                if not paths.is_absolute(str(kubecert_cert)):
                    kubecert_cert = _real_kubeconfig_path(repository_ctx, host_kubeconfig, kubecert_cert)
                    can_symlink = False
                else:
                    kubecert_cert = repository_ctx.path(kubecert_cert)  # requred to be a path object later

            kubecert_key = _kubectl_config_query(
                repository_ctx,
                host_kubeconfig.realpath,
                "{.users[?(@.name == \"%s\")].user.client-key}" % user,
            )
            if kubecert_key:
                if not paths.is_absolute(str(kubecert_key)):
                    kubecert_key = _real_kubeconfig_path(repository_ctx, host_kubeconfig, kubecert_key)
                    can_symlink = False
                else:
                    kubecert_key = repository_ctx.path(kubecert_key)  # requred to be a path object later

        else:
            # Fallback to the legacy behavior used by AdCloud
            # Client certs were located at well known paths
            certs = home.get_child(".kube").get_child("certs")
            ca_crt = certs.get_child("ca.crt")
            kubecert_cert = certs.get_child("kubecert.cert")
            kubecert_key = certs.get_child("kubecert.key")

            # kubeconfig file doesn't exists
            can_symlink = False

    if can_symlink and host_kubeconfig and host_kubeconfig.exists:
        # symlink ~/.kube/config if this file exists
        repository_ctx.symlink(host_kubeconfig, repository_ctx.path("config"))
    else:
        # crete new config file service account token or certificates
        kubeconfig = repository_ctx.path("config")

        # system kubeconfig file can still exists here
        # if that is the case, we try to copy user and cluster settings from the system configuration
        if host_kubeconfig and host_kubeconfig.exists:
            # create a context file that will allow us use kubectl --mininfy=true
            kubeconfig_context = repository_ctx.path("kubeconfig-context")
            repository_ctx.file(
                kubeconfig_context,
                _KUBECONFIG_CONTEXT_TEMPLATE.format(
                    cluster = repository_ctx.attr.cluster,
                    user = user,
                ),
                executable = False,
            )

            # merge system kubeconfig with the newly created context configuration
            exec_result = repository_ctx.execute(
                [kubectl, "config", "view", "--merge=true", "--minify=true", "--raw"],
                environment = {
                    # enable merge
                    "KUBECONFIG": "%s:%s" % (kubeconfig_context, host_kubeconfig.realpath),
                    # prevent kubectl config to stumble on shared .kube/config.lock file
                    "HOME": str(repository_ctx.path(".")),
                },
                quiet = True,
            )
            if exec_result.return_code != 0:
                fail("Error executing kubectl config view --merge=true --minify=true --raw")

            # write merged kubeconfig
            repository_ctx.file(
                kubeconfig,
                exec_result.stdout,
                executable = False,
            )

            # remove context file, it must not be left behind
            repository_ctx.delete(kubeconfig_context)

        # Update server endpoint. Ether service account is found or server is passed as a parameter.
        # config set-cluster {cluster} \
        #     --certificate-authority=... \
        #     --server=https://dev3.k8s.tubemogul.info:443 \
        #     ",
        if server and ca_crt and ca_crt.exists:
            _kubectl_config(repository_ctx, kubeconfig, [
                "set-cluster",
                repository_ctx.attr.cluster,
                "--server",
                server,
                "--certificate-authority",
                ca_crt.realpath,  # must be an absolute path
            ])

        # Update user credentials token in case the service account is found.
        # config set-credentials {user} --token=...",
        if token:
            _kubectl_config(repository_ctx, kubeconfig, [
                "set-credentials",
                user,
                "--token",
                token,
            ])

        # Update user credentials certificate.
        # config set-credentials {user} --client-certificate=...",
        if kubecert_cert and kubecert_cert.exists:
            _kubectl_config(repository_ctx, kubeconfig, [
                "set-credentials",
                user,
                "--client-certificate",
                kubecert_cert.realpath,  # must be an absolute path
            ])

        # Update user credentials certificate.
        # config set-credentials {user} --client-key=...",
        if kubecert_key and kubecert_key.exists:
            _kubectl_config(repository_ctx, kubeconfig, [
                "set-credentials",
                user,
                "--client-key",
                kubecert_key.realpath,  # must be an absolute path
            ])

    # export repostory contents
    repository_ctx.file("BUILD", _KUBECONFIG_BUILD_TEMPLATE.format(
        cluster = repository_ctx.attr.cluster,
        server = repository_ctx.attr.server,
        user = user,
    ), False)

    return {
        "cluster": repository_ctx.attr.cluster,
        "server": repository_ctx.attr.server,
        "user": user,
    }

kubeconfig_configure = repository_rule(
    attrs = {
        "cluster": attr.string(
            doc = "The Kubernetes cluster name as defined in the host kubectl configuration.",
            mandatory = True,
        ),
        "server": attr.string(
            doc = "Kubernetes server endpoint.",
            mandatory = False,
        ),
        "user": attr.string(
            doc = "Kubernetes configuration user name.",
            mandatory = False,
        ),
    },
    environ = [
        "HOME",
        "USER",
        "KUBERNETES_SERVICE_HOST",
        "KUBERNETES_SERVICE_PORT",
    ],
    local = True,
    implementation = _kubeconfig_configure_impl,
)
